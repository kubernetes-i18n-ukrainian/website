---
<!--title: Using a Service to Expose Your App
-->
title: Використання сервісу для відкриття застосунку за межі кластера
weight: 10
---

<!DOCTYPE html>

<html lang="en">

<body>

<link href="/docs/tutorials/kubernetes-basics/public/css/styles.css" rel="stylesheet">

<div class="layout" id="top">

	<main class="content">

		<div class="row">
			<div class="col-md-8">
            <!--<h3>Objectives</h3>
            -->
            <h3>Цілі</h3>
				<ul>
                    <!--<li>Learn about a Service in Kubernetes</li>
                    -->
                    <li>Зрозуміти, що таке сервіс у Kubernetes</li>
                    <!--<li>Understand how labels and LabelSelector objects relate to a Service</li>
                    -->
                    <li>Зрозуміти, яке відношення до сервісу мають мітки та об’єкти селектора міток</li>
                    <!--<li>Expose an application outside a Kubernetes cluster using a Service</li>
                    -->
                    <li>Відкрити застосунок за межі Kubernetes кластера за допомогою сервісу</li>
				</ul>
			</div>

			<div class="col-md-8">
            <!--<h3>Overview of Kubernetes Services</h3>
            -->
            <h3>Загальна інформація про Kubernetes сервіси</h3>

            <!--<p>Kubernetes <a href="/docs/concepts/workloads/pods/pod-overview/">Pods</a> are mortal. Pods in fact have a <a href="/docs/concepts/workloads/pods/pod-lifecycle/">lifecycle</a>. When a worker node dies, the Pods running on the Node are also lost. A <a href="/docs/concepts/workloads/controllers/replicaset/">ReplicaSet</a> might then dynamically drive the cluster back to desired state via creation of new Pods to keep your application running. As another example, consider an image-processing backend with 3 replicas. Those replicas are exchangeable; the front-end system should not care about backend replicas or even if a Pod is lost and recreated. That said, each Pod in a Kubernetes cluster has a unique IP address, even Pods on the same Node, so there needs to be a way of automatically reconciling changes among Pods so that your applications continue to function.</p>
            -->
            <p><a href="/docs/concepts/workloads/pods/pod-overview/">Поди</a> Kubernetes “вмирають” і мають власний <a href="/docs/concepts/workloads/pods/pod-lifecycle/">цикл життя</a>. Коли робочий вузол припиняє роботу, ми також втрачаємо всі поди, запущені на ньому. Абстракція <a href="/docs/concepts/workloads/controllers/replicaset/">ReplicaSet</a> здатна динамічно повернути кластер до бажаного стану шляхом створення нових подів, щоб забезпечити безперебійність роботи вашого застосунку. Як інший приклад, візьмемо бекенд застосунку для обробки зображень із трьома репліками. Ці репліки взаємозамінні; система фронтенду не повинна зважати на репліки серверної частини або на загибель і відтворення поду. Водночас, кожний под у Kubernetes кластері має унікальну IP-адресу, навіть поди на одному вузлі. Відповідно, має бути спосіб автоматично синхронізувати зміни між подами для того, щоб ваші застосунки продовжували працювати.</p>

            <!--<p>A Service in Kubernetes is an abstraction which defines a logical set of Pods and a policy by which to access them. Services enable a loose coupling between dependent Pods. A Service is defined using YAML <a href="/docs/concepts/configuration/overview/#general-configuration-tips">(preferred)</a> or JSON, like all Kubernetes objects. The set of Pods targeted by a Service is usually determined by a <i>LabelSelector</i> (see below for why you might want a Service without including <code>selector</code> in the spec).</p>
            -->
            <p>Сервіс у Kubernetes - це абстракція, що визначає логічний набір подів і політику доступу до них. Сервіси уможливлюють слабку зв’язаність між залежними подами. Для визначення сервісу використовують YAML-файл <a href="/docs/concepts/configuration/overview/#general-configuration-tips">(рекомендовано)</a> або JSON, як для решти об’єктів Kubernetes. Набір подів, призначених для сервісу, зазвичай визначається <i>селектором міток</i> (нижче пояснюється, чому параметр <code>selector</code> іноді не включають у специфікацію сервісу).</p>

            <!--<p>Although each Pod has a unique IP address, those IPs are not exposed outside the cluster without a Service. Services allow your applications to receive traffic. Services can be exposed in different ways by specifying a <code>type</code> in the ServiceSpec:</p>
            -->
            <p>Попри те, що кожен под має унікальний IP, ці IP-адреси не видні за межами кластера без сервісу. Сервіси уможливлюють трафік до ваших застосунків. Відкрити сервіс можна по-різному; це обумовлюється параметром <code>type</code> у специфікації сервісу:</p>
			<ul>
                <!--<li><i>ClusterIP</i> (default) - Exposes the Service on an internal IP in the cluster. This type makes the Service only reachable from within the cluster.</li>
                -->
                <li><i>ClusterIP</i> (типове налаштування) - відкриває сервіс у кластері за внутрішнім IP. Цей тип робить сервіс доступним лише у межах кластера.</li>
                <!--<li><i>NodePort</i> - Exposes the Service on the same port of each selected Node in the cluster using NAT. Makes a Service accessible from outside the cluster using <code>&lt;NodeIP&gt;:&lt;NodePort&gt;</code>. Superset of ClusterIP.</li>
                -->
                <li><i>NodePort</i> - відкриває сервіс на тому самому порті кожного обраного вузла в кластері, використовуючи NAT. Робить сервіс доступним поза межами кластера, використовуючи <code>&lt;NodeIP&gt;:&lt;NodePort&gt;</code>. Супермножина ClusterIP.</li>
                <!--<li><i>LoadBalancer</i> - Creates an external load balancer in the current cloud (if supported) and assigns a fixed, external IP to the Service. Superset of NodePort.</li>
                -->
                <li><i>LoadBalancer</i> - створює зовнішній балансувальник навантаження у вашій хмарі (за умови хмарної інфраструктури) і призначує сервісу статичну зовнішню IP-адресу. Супермножина NodePort.</li>
                <!--<li><i>ExternalName</i> - Exposes the Service using an arbitrary name (specified by <code>externalName</code> in the spec) by returning a CNAME record with the name. No proxy is used. This type requires v1.7 or higher of <code>kube-dns</code>.</li>
                -->
                <li><i>ExternalName</i> - відкриває сервіс, використовуючи довільне ім’я (визначається параметром <code>externalName</code> у специфікації), з яким повертає запис CNAME. Проксі не використовується. Цей тип потребує версії <code>kube-dns</code> 1.7 і вище.</li>
			</ul>
            <!--<p>More information about the different types of Services can be found in the <a href="/docs/tutorials/services/source-ip/">Using Source IP</a> tutorial. Also see <a href="/docs/concepts/services-networking/connect-applications-service">Connecting Applications with Services</a>.</p>
            -->
            <p>Більше інформації про різні типи сервісів ви знайдете у навчальному матеріалі <a href="/docs/tutorials/services/source-ip/">Використання початкової IP-адреси</a>. Дивіться також <a href="/docs/concepts/services-networking/connect-applications-service">Використання сервісів для поєднання застосунків</a>.</p>
            <!--<p>Additionally, note that there are some use cases with Services that involve not defining <code>selector</code> in the spec. A Service created without <code>selector</code> will also not create the corresponding Endpoints object. This allows users to manually map a Service to specific endpoints. Another possibility why there may be no selector is you are strictly using <code>type: ExternalName</code>.</p>
            -->
            <p>Також зауважте, що для деяких сценаріїв використання сервісів параметр <code>selector</code> не задається у специфікації сервісу. Сервіс, створений без визначення параметра <code>selector</code>, також не створюватиме відповідного кінцевого об’єкта. Це дозволяє користувачам вручну спроектувати сервіс на конкретні кінцеві точки. Інший випадок, коли селектор може бути не потрібний - використання строго заданого параметра <code>type: ExternalName</code>.</p>
			</div>
			<div class="col-md-4">
				<div class="content__box content__box_lined">
                    <!--<h3>Summary</h3>
                    -->
                    <h3>Стислий зміст</h3>
					<ul>
                        <!--<li>Exposing Pods to external traffic</li>
                        -->
                        <li>Відкриття подів для зовнішнього трафіка</li>
                        <!--<li>Load balancing traffic across multiple Pods</li>
                        -->
                        <li>Балансування навантаження трафіка між подами</li>
                        <!--<li>Using labels</li>
                        -->
                        <li>Використання міток</li>
					</ul>
				</div>
				<div class="content__box content__box_fill">
                        <!--<p><i>A Kubernetes Service is an abstraction layer which defines a logical set of Pods and enables external traffic exposure, load balancing and service discovery for those Pods.</i></p>
                        -->
                        <p><i>Kubernetes сервіс - це рівень абстракції, який визначає логічний набір подів і відкриває їх для зовнішнього трафіка, балансує навантаження і здійснює виявлення сервісів для цих подів.</i></p>
				</div>
			</div>
		</div>
		<br>

		<div class="row">
			<div class="col-md-8">
                <!--<h3>Services and Labels</h3>
                -->
                <h3>Сервіси і мітки</h3>
			</div>
		</div>

		<div class="row">
			<div class="col-md-8">
				<p><img src="/docs/tutorials/kubernetes-basics/public/images/module_04_services.svg" width="150%" height="150%"></p>
			</div>
		</div>

		<div class="row">
			<div class="col-md-8">
                <!--<p>A Service routes traffic across a set of Pods. Services are the abstraction that allow pods to die and replicate in Kubernetes without impacting your application. Discovery and routing among dependent Pods (such as the frontend and backend components in an application) is handled by Kubernetes Services.</p>
                -->
                <p>Сервіс маршрутизує трафік між подами, що входять до його складу. Сервіс - це абстракція, завдяки якій поди в Kubernetes “вмирають” і відтворюються, не впливаючи на роботу вашого застосунку. Сервіси в Kubernetes здійснюють виявлення і маршрутизацію між залежними подами (як наприклад, фронтенд- і бекенд-компоненти  застосунку).</p>
                <!--<p>Services match a set of Pods using <a href="/docs/concepts/overview/working-with-objects/labels">labels and selectors</a>, a grouping primitive that allows logical operation on objects in Kubernetes. Labels are key/value pairs attached to objects and can be used in any number of ways:</p>
                -->
                <p>Сервіси співвідносяться з набором подів за допомогою <a href="/docs/concepts/overview/working-with-objects/labels">міток і селекторів</a> -- групувальних примітивів, що роблять можливими логічні операції з об’єктами у Kubernetes. Мітки являють собою пари ключ / значення, що приєднуються до об’єктів і використовуються для різних цілей:</p>
				<ul>
                    <!--<li>Designate objects for development, test, and production</li>
                    -->
                    <li>Позначити об’єкти для розробки, тестування і прод оточення</li>
                    <!--<li>Embed version tags</li>
                    -->
                    <li>Прикріпити мітку версіонування</li>
                    <!--<li>Classify an object using tags</li>
                    -->
                    <li>Класифікувати об’єкт за допомогою мітки</li>
				</ul>

			</div>
			<div class="col-md-4">
				<div class="content__box content__box_fill">
                    <!--<p><i>You can create a Service at the same time you create a Deployment by using<br><code>--expose</code> in kubectl.</i></p>
                    -->
                    <p><i>Ви можете створити сервіс одночасно із Deployment, виконавши команду <br><code>--expose</code> в kubectl.</i></p>
				</div>
			</div>
		</div>

		<br>

		<div class="row">
			<div class="col-md-8">
				<p><img src="/docs/tutorials/kubernetes-basics/public/images/module_04_labels.svg"></p>
			</div>
		</div>
		<br>
		<div class="row">
			<div class="col-md-8">
                <!--<p>Labels can be attached to objects at creation time or later on. They can be modified at any time. Let's expose our application now using a Service and apply some labels.</p>
                -->
                <p>Мітки можна прикріпити до об’єктів під час створення або пізніше, їх можна змінити у будь-який час. А зараз давайте відкриємо наш застосунок за допомогою сервісу і прикріпимо мітки.</p>
			</div>
		</div>
		<br>
		<div class="row">
			<div class="col-md-12">
				<a class="btn btn-lg btn-success" href="/docs/tutorials/kubernetes-basics/expose/expose-interactive/" role="button">Почати інтерактивний урок<span class="btn__next">›</span></a>
			</div>
		</div>
	</main>
</div>

</body>
</html>
